%!TEX root = main.tex

\section{Implementación}

\subsection{Tecnología elegida}
Al pensar cuál podría ser la tecnología más adecuada para desarrollar el \runner, lo primero que surge es evaluar con qué tecnologías fueron construidos los \runner s existentes y cuánto de ello podría ser reutilizado.

\sepfootnotecontent
  {Gema}
  {Nombre con el que se conoce a las bibliotecas de código Ruby. Tienen la particularidad de ser muy fáciles de publicar y usar, favoreciendo así la reutilización de componentes.}

En el momento en que empecé a planificar la integración, Mumuki soportaba solamente 3 lenguajes: Haskell, con un \runner\ escrito en Haskell, y Prolog y Ruby, ambos con \runner s escritos en Ruby. Estos dos últimos compartían parte de su código mediante la utilización de la gema\sepfootnote{Gema} \mumukit, encargada de resolver las cuestiones de comunicación con el Atheneum, dejando como tarea para el programador la implementación de algunos pocos métodos que se encargan de lo necesario para ejecutar los programas.

Ante este escenario, resulta evidente que la elección de Ruby como lenguaje de soporte para el \runner\ de Gobstones era la más acertada.

\subsection{Stones Spec}
Una vez elegida la tecnología, me aboqué a la primera tarea: crear un framework para poder correr tests unitarios sobre programas, procedimientos o funciones Gobstones. En cualquier lenguaje de propósito general, estos frameworks están codificados utilizando el mismo lenguaje sobre el cual se van a ejecutar las pruebas pero como Gobstones no es un lenguaje de propósito general, esto no era una opción. Por simplicidad y para no introducir otro nuevo lenguaje, elegí utilizar también Ruby para esta tarea.

Tras analizar algunos ejercicios de las guías de Introducción a la Programación, diseñé un modelo de prueba que consta de los siguientes atributos:

\begin{itemize}
  \caracteristica{Subject} nombre del procedimiento o función que se desea probar. Si se lo omite, las pruebas se realizan sobre el programa completo.
  \caracteristica{Check head position} indica si las pruebas deben verificar la posición del cabezal.
  \caracteristica{Examples} lista de ejemplos que serán probados, la estructura dependerá del sujeto que se esté probando.

  En el caso de un \emph{programa}, cada ejemplo constará de una dupla \codigo{(tablero inicial, tablero final)} (ver código \ref{lst:ProgramSpec}); para un \emph{procedimiento} con parámetros, deberán especificarse también los parámetros con los cuales será ejecutado, resultando en una terna \codigo{(parámetros, tablero inicial, tablero final)} (ver código \ref{lst:ProcedureSpec}); y para una \emph{función} deberá especificarse el resultado esperado en vez del tablero final, resultando en una terna \codigo{(parámetros, tablero inicial, resultado)} (ver código \ref{lst:FunctionSpec}).
\end{itemize}

\begin{listing}
  \centering

  \begin{minted}{yaml}
  check_head_position: true
  examples:
   - initial_board: |
       GBB/1.0
       size 2 2
       head 0 0
     final_board: |
       GBB/1.0
       cell 1 1 Rojo 1
       size 2 2
       head 1 1
  \end{minted}

  \caption{Ejemplo de un test de \emph{programa}, que chequea que haya una bolita roja en la celda \codigo{(1, 1)} y que el cabezal se encuentre allí.}
  \label{lst:ProgramSpec}
\end{listing}

\begin{listing}
  \centering

  \begin{minted}{yaml}
  subject: PonerN
  examples:
   - arguments:
      - 2
      - Azul
     initial_board: |
       GBB/1.0
       size 2 2
       head 0 0
     final_board: |
       GBB/1.0
       size 2 2
       cell 0 0 Azul 2
       head 0 0
  \end{minted}

  \caption{Ejemplo de un test de \emph{procedimiento}, que chequea que \codigo{PonerN} pone 2 bolitas azules cuando es llamado con los argumentos \codigo{(2, Azul)}.}
  \label{lst:ProcedureSpec}
\end{listing}

\begin{listing}
  \centering

  \begin{minted}{yaml}
  subject: nroBolitasTotal
  examples:
   - initial_board: |
       GBB/1.0
       size 2 2
       cell 0 0 Rojo 1 Azul 2 Negro 2 Verde 5
       head 0 0
     return: 10
  \end{minted}

  \caption{Ejemplo de un test de \emph{función}, que chequea que \codigo{nroBolitasTotal} devuelve 10 en una celda con 10 bolitas.}
  \label{lst:FunctionSpec}
\end{listing}

\borrador{Contar brevemente cómo se implementó: se crean archivos temporales con el programa y los tableros iniciales, se ejecuta, se parsea el resultado de la consola o del archivo GBB de salida.}

\subsection{Trabajando con \mumukit}
En particular, \mumukit\ exige que se implementen al menos dos métodos:
\begin{itemize}
  \item{\codigo{compile}: que recibe la solución del estudiante, el código extra provisto por el docente y el código de las pruebas, y debe encargarse de unirlos;}
  \item{\codigo{run\_test\_command}: que recibe el archivo generado por el método anterior y debe encargarse de ejecutar las pruebas y devolver el resultado.}
\end{itemize}

En cualquier otro \runner, programar el \codigo{compile} es muy sencillo: como todos los bloques de código están expresados en el lenguaje que se intenta probar, basta con yuxtaponerlos. Como vimos anteriormente, un test unitario en Gobstones no es un archivo de código sino una representación YAML de una serie de configuraciones, y eso es lo que se genera en este caso.

\subsection{Extensiones a Mumuki}
\borrador{
  \begin{itemize}
    \item poder mostrar el resultado de una ejecución, para no perder el componente visual de Gobstones. Hasta el momento no existía ya que en otros lenguajes no interesaba mostrar el resultado
    \item soportar HTML como output de un runner
  \end{itemize}
}

\subsection{Mumuki Gobstones Server}
\subsubsection{Integración con Stones Spec}
\subsubsection{Chequeo de expectativas}
