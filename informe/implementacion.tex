%!TEX root = main.tex

\section{Implementación}

\subsection{Tecnología elegida}
Al pensar cuál podría ser la tecnología más adecuada para desarrollar el \runner, lo primero que surge es evaluar con qué tecnologías fueron construidos los \runner s existentes y cuánto de ello podría ser reutilizado.

\sepfootnotecontent
  {Gema}
  {Nombre con el que se conoce a las bibliotecas de código Ruby. Tienen la particularidad de ser muy fáciles de publicar y usar, favoreciendo así la reutilización de componentes.}

En el momento en que empecé a planificar la integración, Mumuki soportaba solamente 3 lenguajes: Haskell, con un \runner\ escrito en Haskell, y Prolog y Ruby, ambos con \runner s escritos en Ruby. Estos dos últimos compartían parte de su código mediante la utilización de la gema\sepfootnote{Gema} \mumukit, encargada de resolver las cuestiones de comunicación con el Atheneum, dejando como tarea para el programador la implementación de algunos pocos métodos que se encargan de lo necesario para ejecutar los programas.

Ante este escenario, resulta evidente que la elección de Ruby como lenguaje de soporte para el \runner\ de Gobstones era la más acertada.

\subsection{Stones Spec}
Una vez elegida la tecnología, me aboqué a la primera tarea: crear un framework para poder correr tests unitarios sobre programas, procedimientos o funciones Gobstones. En cualquier lenguaje de propósito general, estos frameworks están codificados utilizando el mismo lenguaje sobre el cual se van a ejecutar las pruebas pero como Gobstones no es un lenguaje de propósito general, esto no era una opción. Para no introducir otro nuevo lenguaje, elegí utilizar también Ruby para esta tarea.

Tras analizar algunos ejercicios de las guías de Introducción a la Programación, diseñé un modelo de prueba que consta fundamentalmente de dos cosas: un \emph{sujeto} y una colección de \emph{ejemplos}. El sujeto es el nombre del procedimiento o función que se desea probar; si se lo omite, las pruebas se realizan sobre el programa completo. Los ejemplos son uno o más escenarios sobre los cuales se desea probar al sujeto, cómo están compuestos esos ejemplos dependerá del tipo de sujeto.

En el caso de un \emph{programa}, cada ejemplo constará de una dupla \codigo{(tablero inicial, tablero final)}; para un \emph{procedimiento}, deberán especificarse también los argumentos con los cuales será ejecutado, resultando en una terna \codigo{(parámetros, tablero inicial, tablero final)}; y para una \emph{función} deberá especificarse el resultado esperado en vez del tablero final, resultando en una terna \codigo{(parámetros, tablero inicial, resultado)}.

\sepfootnotecontent
  {YAML}
  {Acrónimo de \emph{YAML Ain't Markup Language}, YAML es un formato ``human friendly'' de serialización de datos, estándar para muchos lenguajes de programación. En particular, es el más utilizado dentro de la comunidad Ruby, soportado nativamente por el lenguaje.}

Para representar estas pruebas utilicé el formato YAML\sepfootnote{YAML}, principalmente por su facilidad de escritura y su fácil integración con Ruby. Pueden verse algunos ejemplos en el apéndice \ref{app:Specs}.

\borrador{Contar brevemente cómo se implementó: se crean archivos temporales con el programa y los tableros iniciales, se ejecuta, se parsea el resultado de la consola o del archivo GBB de salida.}

\subsection{Trabajando con \mumukit}
En particular, \mumukit\ exige que se implementen al menos dos métodos:
\begin{itemize}
  \item{\codigo{compile}: que recibe la solución del estudiante, el código extra provisto por el docente y el código de las pruebas, y debe encargarse de unirlos;}
  \item{\codigo{run\_test\_command}: que recibe el archivo generado por el método anterior y debe encargarse de ejecutar las pruebas y devolver el resultado.}
\end{itemize}

En cualquier otro \runner, programar el \codigo{compile} es muy sencillo: como todos los bloques de código están expresados en el lenguaje que se intenta probar, basta con yuxtaponerlos. Como vimos anteriormente, un test unitario en Gobstones no es un archivo de código sino una representación YAML de una serie de configuraciones, y eso es lo que se genera en este caso.

\subsection{Extensiones a Mumuki}
\borrador{
  \begin{itemize}
    \item poder mostrar el resultado de una ejecución, para no perder el componente visual de Gobstones. Hasta el momento no existía ya que en otros lenguajes no interesaba mostrar el resultado
    \item soportar HTML como output de un runner
  \end{itemize}
}

\subsection{Mumuki Gobstones Server}
\subsubsection{Integración con Stones Spec}
\subsubsection{Chequeo de expectativas}
